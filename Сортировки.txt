Сортировки:
1) Линейный выбор с обменом
Условно делим массив на 2 части: отсортированную и неотсортированную, затем ищем минимальный элемент и тянем его вначало, пока те что слева меньше. Сложность O(n^2).

2) Линейный выбор с подсчетом
Есть массив, завдим второй (счетчиков), каждому элементу из исходного массива соответствует элемент из массива счетчиков (индексы одинаковы). Изначально забиваем счетчики нулями и начинаем перебирать квадратичным образом элементы. При этом делаем такую вещь: элементы сравниваем: Если больше элемент а, то инкрементируем ячейку а массива индексов; иначе инкрементируем ячейку b. В результате в новом массиве получаем индексы для всех элементов, потом переставляем. Сложность O(n^2) + еще по памяти проигрываем.

3) Шейкер сортировка: пузырек в 2 стороны;

4) Метод простой вставки: делим массив на 2 части; каждый раз берем элемент из неотсортированной части и сдвигаем влево пока он больше. O(n^2);

5) Место для вставки находим бинарным поиском по отсортированному массиву. Место для вставки находится за O(log(n)), но потом элементы надо подвинуть за O(n) поэтому O(n^2);

6) Пирамидальная сортировка (сортировка кучей):
Есть куча (бинарное дерево):
- корень больше чем его дети;
- поддеревья - тоже кучи;
- должно быть полное бинарное дерево (заполнены все уровне, кроме последнего, последний не заполнен с конца);

Свойства кучи: 
- максимальный элемент в корне;
- все элементы кучи можно однозначно разместить в массиве (но не произвольное бинарное дерево);

массив:
-------------------
1 5 8 6 7 5 4 1 2 9
-------------------
  ||
  \/
куча:
    1
   5 8
 6 7 5 4
1 2 9

Идея пирамидальной сортировки (heapsort):
1) интерпретировать массив как кучу;
2) делаем изменения, чтобы исправить нарушения свойства кучи; 
3) разбираем полученную кучу начиная с максимального элемента;

У элементов которых нет детей с "кучностью" все ок. В массиве эти элементы будут располагаться примерно во второй половие массива. Докажем:

Элемент i:

left = 2 * i + 1
right = 2 * i + 2
-дети

родитель: (i - 1) / 2 - благодаря целочисленному делению

последний родитель: ((n - 1) - 1) / 2 = (n / 2) - 1

Теперь начиная с последнего родителя будем восстанавливать свойства кучи:

Должны взять 3 элемента (м.б. 2) и переставить друг с другом, восстанавливаем свойства кучи для того что мы получим в результате перестановок. Для этого определим функцию sift_down (просеить вниз), отсюда и название: пирамидальная сортировка с просеиванием.

Мы идем с конца т.к. сначала нельзя - первые поддеревья не кучи.

void heapify(int *arr, int n)
{
	// начиная от последнего элемента с детьми
  for (int i = n / 2 - 1; i >= 0; i--) {
    // восстанавливает свойства кучи для элемента,
    // при условии, что дети этого элемента сами являются кучами
    sift_down(int *arr, int n, int i);
  }
}

void sift_down(int *arr, int n, int i)
{
  int left = 2 * i + 1;
  int right = 2 * i + 2;
  int max = arr[i];
  // сначала находим максимум из трех элементов: i, left, right
  // и меняем его местами с i
  int max_i = 1;
  if (left < n && arr[left] > max) {
    max = arr[left];
    max_i = left;
  }
  if (right < n && arr[right] > max) {
    max = arr[right];
    max_i = right;
  }
  if (max_i != i) {
    // меняем местами
    arr[max_i] = arr[i];
    arr[i] = max;
    // возможно мы поломали одну из куч. Восстановим ее:
    sift_down(arr, n, max_i);
  }
}

Чтобы построить структуру "куча" на нашем массиве:
- пройдемся по всем элементам у которых есть дети в обратном порядке и восстановим (возможно поломанные) свойства кучи на этом элементе
- можно заметить, что к моменту, когда мы дойдем до i-го элемента, оба его ребенка уже будут обработаны, и единственное место, где оно может быть нарушено - сам i-й элемент.

У функции heapify сложность O(n)

void heap_sort(int *arr, int n) {
  heapify(arr, n); //строим кучу
  // разбираем кучу
  int k = n; // размер оставшейся кучи
  while (k > 1) {
    int tmp = arr[k - 1];
    arr[k - 1] = arr[0];
    arr[0] = tmp;
    k--;
    sift_down(arr, k, 0);
  } 
}

Сложность сортировки кучей O(n * log(n)) из-за этого цикла где ломается корневая куча.

7) Слияние:
1) бьем массив пополам
2) рекурсивно сортируем
3) слияние

- для слияния понадобится дополнительная память, поэтому заведем еще 1 массив размера O(n)
- исходный массив дробится на куски размера 1 и попарно сливается
- сливаем массивы размера 2 (попарно)
пока не получится массив размера n не отсортируется




8) Быстрая сортировка Хоара
Каждый раз мы делим массив на 2 части. В одной части все элементы меньшие опорного, в другой части - все элементы, большие опорного. Таким образом получаем 2 подмассива, элемент из одного из которых не может оказаться в другом. После этого мы рекурсивно их сортируем точно таким же способом.

Сортировка Хоара состоит из:
- рекурсивного вызова самого себя
- на каждом вызове выбор опорного элемента, разбиение на 2 части относительно этого элемента и 2 рекурсивных вызова.

void hoar(int *arr, int n)
{
  if (n <= 1)
    return;
  int p = peek_pivot(arr, n); // опорный элемент
  int i = partice(arr, n, p); // индекс границы (Ломуто или Хоар)
  hoar(arr, i);
  hoar(arr + i, n - i);
}

Вычисление опорного элемента:

1) Если брать в качестве опорного элемента первый, то если массив уже отсортирован, то левая часть будет состоять из одного элемента, а правая часть из n - 1 элемента. И тогда сложность o(n^2) - ужас

Идеальный выбор опорного элемента - делить пополам.

2) Вычисляем медиану: сложность минимум o(n). Поэтому опять получается медленно.

3) случайный - неплохо, даже если один раз будет выбрано неудачно.
4) Взять 1, последний серидину и найти медиану между них. O(1)


---------------------- ПРИМЕР ---------------------------------
Возьмем массив n = 17
4 6 3 2 7 89 2 0 4 67 3 2 76 4 2 0 3 21
4 21 и 4
Найдем p как медиану из первого, последнего и среднего элементов: (4, 4, 21) = 4;

Переставили элементы так что слева от некоторой границы окажутся элементы <= 4, а справа - элементы >= 4;
Индекс границы i = 10

3 2 2 0 3 2 2 0 3 | 4 6 7 89 4 67 76 4 21

Дальше сортируем рекурсивно левую часть (0-9) и правую (10-16)

---------------------------------------------------------------

Ищем такую границу, для которой можно разбить массив на 2 части: левую и правую. Есть 2 варианта:

1) Разбиение Ломуто:

Интересный факт: Ломуто можно оптимизировать с точки зрения архитектуры процессора, т.к. с помощью хитрой арифметики можно избежать ветвления и тем самым разгрузить процессор (т к он прогнозирует каждый if)

int lomuto_partice(int *arr, int n, int p_index)
{
  int p = arr[p_index];
  swap(arr, p, n - 1); //оттащим опорный элемент в самый конец, чтобы после разбиения хотя бы 1 оказался в правой части и не получилось бы разбиения на 0 и n элементов
  int i = 0, k = 0;
  while (i < n - 1) { // кроме последнего, большего p 
    if (arr[i] > arr[p_index]) {
      i++;
    } else {
      swap(arr, p_index, n - 1);
      int tmp = arr[i];
      arr[i] = arr[k];
      arr[k] = tmp;
      i++;
      k++;
    }
  }
  return k;
}

Разбиение Ломуто можно модифицировать так чтобы получилось разбиение массива на 3 части: все элементы < pivot, = pivot, > pivot.

2) Разбиение Хоара: 
Одновременно идут 2 индекса: один слева, другой справа.

2 счетчика: i движется вправо, j - влево, пока встречаем элементы меньше (больше) чем p.

int hoar_partice(int *arr, int n, int p)
{
  int pivot = arr[p];
  while (i < j) {
    while (arr[i] < pivot) i++;
    while (arr[j] > pivot) j--;
    if (i < j) {
      swap(arr, i, j);
      i++;
      j--;
    }
  }
  return i;
}

--------------------- ХОАР ---------------------
i             j
-------------------
2 2 2 2 2 2 6 1 78
-------------------
pivot = 2
-------------------
1 2 2 2 2 2 6 2 78
-------------------
  j         i
-------------------
1 2 2 2 2 2 6 2 78
-------------------
      i j
       |

------------------------------------------------

ИЗБАВЛЯЕМСЯ ОТ РЕКУРСИИ В ХОАРЕ

------------------------------------------------

