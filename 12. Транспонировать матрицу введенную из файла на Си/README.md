Файл main.c не работает: невыход из цикла
# Сортировка Хоара
Каждый раз мы делим массив на 2 части. В одной части все элементы меньшие опорного, в другой части - все элементы, большие опорного. Таким образом получаем 2 подмассива, элемент из одного из которых не может оказаться в другом. После этого мы рекурсивно их сортируем точно таким же способом. <br>

Сортировка Хоара состоит из: <br>
- рекурсивного вызова самого себя <br>
- на каждом вызове выбор опорного элемента, разбиение на 2 части относительно этого элемента и 2 рекурсивных вызова. <br>
``` c
void hoar(int *arr, int n)
{
  if (n <= 1)
    return;
  int p = peek_pivot(arr, n); // опорный элемент
  int i = partice(arr, n, p); // индекс границы (Ломуто или Хоар)
  hoar(arr, i);
  hoar(arr + i, n - i);
}
```
Вычисление опорного элемента: <br>

1) Если брать в качестве опорного элемента первый, то если массив уже отсортирован, то левая часть будет состоять из одного элемента, а правая часть из n - 1 элемента. И тогда сложность o(n^2) - ужас <br>
2) Вычисляем медиану: сложность минимум o(n). Поэтому опять получается медленно. <br>
3) случайный - неплохо, даже если один раз будет выбрано неудачно. <br>
4) Взять 1, последний серидину и найти медиану между них. O(1) <br>


---------------------- ПРИМЕР --------------------------------- <br>
Возьмем массив n = 17 <br>
4 6 3 2 7 89 2 0 4 67 3 2 76 4 2 0 3 21 <br>
4 21 и 4 <br>
Найдем p как медиану из первого, последнего и среднего элементов: (4, 4, 21) = 4; <br>

Переставили элементы так что слева от некоторой границы окажутся элементы <= 4, а справа - элементы >= 4;
Индекс границы i = 10

3 2 2 0 3 2 2 0 3 | 4 6 7 89 4 67 76 4 21

Дальше сортируем рекурсивно левую часть (0-9) и правую (10-16)

---------------------------------------------------------------

Ищем такую границу, для которой можно разбить массив на 2 части: левую и правую. Есть 2 варианта: <br>

1) Разбиение Ломуто: <br>

Интересный факт: Ломуто можно оптимизировать с точки зрения архитектуры процессора, т.к. с помощью хитрой арифметики можно избежать ветвления и тем самым разгрузить процессор (т к он прогнозирует каждый if) <br>

``` c
int lomuto_partice(int *arr, int n, int p_index)
{
  int p = arr[p_index];
  swap(arr, p, n - 1); //оттащим опорный элемент в самый конец, чтобы после разбиения хотя бы 1 оказался в правой части и не получилось бы разбиения на 0 и n элементов
  int i = 0, k = 0;
  while (i < n - 1) { // кроме последнего, большего p 
    if (arr[i] > arr[p_index]) {
      i++;
    } else {
      swap(arr, p_index, n - 1);
      int tmp = arr[i];
      arr[i] = arr[k];
      arr[k] = tmp;
      i++;
      k++;
    }
  }
  return k;
}
```

Разбиение Ломуто можно модифицировать так чтобы получилось разбиение массива на 3 части: все элементы < pivot, = pivot, > pivot. <br>

2) Разбиение Хоара: <br>
Одновременно идут 2 индекса: один слева, другой справа. <br>

2 счетчика: i движется вправо, j - влево, пока встречаем элементы меньше (больше) чем p. <br>

``` c
int hoar_partice(int *arr, int n, int p)
{
  int pivot = arr[p];
  while (i < j) {
    while (arr[i] < pivot) i++;
    while (arr[j] > pivot) j--;
    if (i < j) {
      swap(arr, i, j);
      i++;
      j--;
    }
  }
  return i;
}
```
--------------------- ХОАР --------------------- <br>
i             j     <br>
------------------- <br>
2 2 2 2 2 2 6 1 78  <br>
------------------- <br>
pivot = 2           <br>
------------------- <br>
1 2 2 2 2 2 6 2 78  <br>
------------------- <br>
  j         i       <br>
------------------- <br>
1 2 2 2 2 2 6 2 78  <br>
------------------- <br>
      i j           <br>
       |            <br>
Источник: лекции Дубинина 
