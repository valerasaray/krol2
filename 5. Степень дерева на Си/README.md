## Линейный список

#### Определение
Линейный список - это представление в ЭВМ конечного упорядоченного динамического мультимножества (множества, допускающее включение одинаковых элементов)
линейно упорядоченных элементов, порядок которых определяется не индексами, как в массиве, а относительным расположением элементов.

![image](https://user-images.githubusercontent.com/55214180/172019871-ad4b721f-e07c-4cc1-870a-8b8c72136043.png)

Список двусвязный (двусторонний), если отношений порядка два

Список закольцованный, если для последнего элемента списка следущий элемент первый, а предыдущий элемент для первого последний
(голова указывает на хвост, а хвост на голову). Таким образом отношения порядка становятся определенными для всех смежных пар элементов списка.

В отличии от очереди и стека элементы списка доступны без извлечения предшествующих элементов.

Линейные списки естественно использовать всякий раз, когда встречаются упорядоченные множества переменного размера, где включение, поиск и удаление элементов должны выполняться в произвольных последовательно достигаемых местах, но с сохранением порядка следования остальных элементов. Заметим, что порядок следования элементов в списке не предполагает упорядоченности хранимых в этих элементах значений.

## Физическое представление
#### Реализация на языке C:
```c
//структура элемента списка
struct node
{
    value_type data;
    struct node *next;
    struct node *prev;
};

//структура итератора
struct iterator
{
    struct node *nod;
};

//структура списка
struct list
{
    struct node *head;
    struct node *tail;
};
```
Для работы со списком можно реализовать следующие функции:
1) Равенство элементов
2) Переход на следующий (предыдущий) элемент
3) Чтение текущего элемента
4) Запись данных в элемент списка
5) Уничтожение списка
6) Размер списка и т.д.



## Итераторы
Итератор - это объект, обладающий функцией перехода от данного элемента списка к соседним.

Итераторы равны, если указывают на один и тот же объект, иначе не равны.

Итератор предоставляет возможность чтения и записи элемента.

Итераторы используются для более удобной навигации по списку, чтения и перезаписи элементов списка.

![image](https://user-images.githubusercontent.com/55214180/172023124-aed6999c-2345-4008-9cf4-321d04b84441.png)

## Алгоритм Кнута-Морриса-Пратта
Иногда необходим поиск подстроки в строке. В худшем случае такой поиск выполняется за O(n * m), где n - длина образца, m - длина строки, что очень затратно. <br>
Поэтому Кнут, Моррис и Пратт придумали более оптимальный алгоритм, работающий за O(m) даже в худшем случае. Идея: <br>
1. Подсчитываем префикс-функцию от образца (заполняем массив префикс функций подстрок образца в соответствии с таким алгоритмом): <br>
    Префикс-функция - функция, которая ставит в соответствие строке максимальную длину суффикса, который совпадает с префиксом, причем вся строка не является суффиксом (префиксом). Например, у строки "aa" префикс-функция равна 1. 
    1.) у 0-го элемента строки значение массива 0, т.к. у подстроки с размером 1 значение префикс-функции равно 0;
    2.) далее берем префикс-функции от подстрок 0:i, где i проходит от 0 до m. Пример: <br>
        +-----------------------------------------------------+ <br>
        | образец:>         | a a b a a c a a b a a c a a a a | <br>
        | префикс-функция:> | 0 1 0 1 2 0 1 2 3 4 5 6 7 8 2 2 | <br>
        +-----------------------------------------------------+ <br>
